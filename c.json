{
	"SLL struct": {
		"prefix": "sllstruct",
		"body": [
			"struct Node { int data; struct Node* next; };"
		],
		"description": "Singly linked list node struct"
	},
	"SLL insert beginning": {
		"prefix": "sllinsbeg",
		"body": [
			"struct Node* insertBeginning(struct Node* head, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val;",
			"    newNode->next = head;",
			"    return newNode;",
			"}"
		],
		"description": "Insert node at beginning of SLL"
	},
	"SLL insert end": {
		"prefix": "sllinsend",
		"body": [
			"struct Node* insertEnd(struct Node* head, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val;",
			"    newNode->next = NULL;",
			"    if (!head) return newNode;",
			"    struct Node* temp = head;",
			"    while (temp->next) temp = temp->next;",
			"    temp->next = newNode;",
			"    return head;",
			"}"
		],
		"description": "Insert node at end of SLL"
	},
	"SLL insert at position": {
		"prefix": "sllinsp",
		"body": [
			"struct Node* insertAtPos(struct Node* head, int pos, int val) {",
			"    if (pos == 0) return insertBeginning(head, val);",
			"    struct Node* temp = head;",
			"    for (int i = 0; temp && i < pos - 1; i++) temp = temp->next;",
			"    if (!temp) return head;",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val;",
			"    newNode->next = temp->next;",
			"    temp->next = newNode;",
			"    return head;",
			"}"
		],
		"description": "Insert node at specified position in SLL"
	},
	"SLL delete beginning": {
		"prefix": "slldelbeg",
		"body": [
			"struct Node* deleteBeginning(struct Node* head) {",
			"    if (!head) return NULL;",
			"    struct Node* temp = head;",
			"    head = head->next;",
			"    free(temp);",
			"    return head;",
			"}"
		],
		"description": "Delete node from beginning of SLL"
	},
	"SLL delete end": {
		"prefix": "slldelend",
		"body": [
			"struct Node* deleteEnd(struct Node* head) {",
			"    if (!head) return NULL;",
			"    if (!head->next) { free(head); return NULL; }",
			"    struct Node* temp = head;",
			"    while (temp->next->next) temp = temp->next;",
			"    free(temp->next);",
			"    temp->next = NULL;",
			"    return head;",
			"}"
		],
		"description": "Delete node from end of SLL"
	},
	"SLL display": {
		"prefix": "slldisp",
		"body": [
			"void display(struct Node* head) {",
			"    while (head) {",
			"        printf(\"%d -> \", head->data);",
			"        head = head->next;",
			"    }",
			"    printf(\"NULL\\n\");",
			"}"
		],
		"description": "Display SLL"
	},
	"SLL search": {
		"prefix": "sllsearch",
		"body": [
			"int search(struct Node* head, int val) {",
			"    int pos = 0;",
			"    while (head) {",
			"        if (head->data == val) return pos;",
			"        head = head->next;",
			"        pos++;",
			"    }",
			"    return -1;",
			"}"
		],
		"description": "Search value in SLL, return position or -1"
	},
	"CSLL struct": {
		"prefix": "csllstruct",
		"body": [
			"struct Node { int data; struct Node* next; };"
		],
		"description": "Circular singly linked list node struct"
	},
	"CSLL insert beginning": {
		"prefix": "csllinsbeg",
		"body": [
			"struct Node* insertBeginning(struct Node* last, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val;",
			"    if (!last) { newNode->next = newNode; return newNode; }",
			"    newNode->next = last->next;",
			"    last->next = newNode;",
			"    return last;",
			"}"
		],
		"description": "Insert node at beginning of CSLL (uses last pointer)"
	},
	"CSLL insert end": {
		"prefix": "csllinsend",
		"body": [
			"struct Node* insertEnd(struct Node* last, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val;",
			"    if (!last) { newNode->next = newNode; return newNode; }",
			"    newNode->next = last->next;",
			"    last->next = newNode;",
			"    return newNode;",
			"}"
		],
		"description": "Insert node at end of CSLL (returns new last)"
	},
	"CSLL delete beginning": {
		"prefix": "cslldelbeg",
		"body": [
			"struct Node* deleteBeginning(struct Node* last) {",
			"    if (!last) return NULL;",
			"    struct Node* temp = last->next;",
			"    if (last == last->next) { free(last); return NULL; }",
			"    last->next = temp->next;",
			"    free(temp);",
			"    return last;",
			"}"
		],
		"description": "Delete node from beginning of CSLL"
	},
	"CSLL delete end": {
		"prefix": "cslldelend",
		"body": [
			"struct Node* deleteEnd(struct Node* last) {",
			"    if (!last) return NULL;",
			"    if (last == last->next) { free(last); return NULL; }",
			"    struct Node* temp = last->next;",
			"    while (temp->next != last) temp = temp->next;",
			"    temp->next = last->next;",
			"    free(last);",
			"    return temp;",
			"}"
		],
		"description": "Delete node from end of CSLL (returns new last)"
	},
	"CSLL display": {
		"prefix": "cslldisp",
		"body": [
			"void display(struct Node* last) {",
			"    if (!last) { printf(\"List Empty\\n\"); return; }",
			"    struct Node* temp = last->next;",
			"    do {",
			"        printf(\"%d -> \", temp->data);",
			"        temp = temp->next;",
			"    } while (temp != last->next);",
			"    printf(\"(points back to %d)\\n\", last->next->data);",
			"}"
		],
		"description": "Display CSLL from head back to head"
	},
	"DLL struct": {
		"prefix": "dllstruct",
		"body": [
			"struct DNode { int data; struct DNode *prev, *next; };"
		],
		"description": "Doubly linked list node struct"
	},
	"DLL insert beginning": {
		"prefix": "dllinsbeg",
		"body": [
			"struct DNode* insertBeginning(struct DNode* head, int val) {",
			"    struct DNode* newNode = (struct DNode*)malloc(sizeof(struct DNode));",
			"    newNode->data = val; newNode->prev = NULL; newNode->next = head;",
			"    if (head) head->prev = newNode;",
			"    return newNode;",
			"}"
		],
		"description": "Insert node at beginning of DLL"
	},
	"DLL insert end": {
		"prefix": "dllinsend",
		"body": [
			"struct DNode* insertEnd(struct DNode* head, int val) {",
			"    struct DNode* newNode = (struct DNode*)malloc(sizeof(struct DNode));",
			"    newNode->data = val; newNode->next = NULL;",
			"    if (!head) { newNode->prev = NULL; return newNode; }",
			"    struct DNode* temp = head; while (temp->next) temp = temp->next;",
			"    temp->next = newNode; newNode->prev = temp;",
			"    return head;",
			"}"
		],
		"description": "Insert node at end of DLL"
	},
	"DLL delete first": {
		"prefix": "dlldelfirst",
		"body": [
			"struct DNode* deleteFirst(struct DNode* head) {",
			"    if (!head) return NULL;",
			"    struct DNode* temp = head;",
			"    head = head->next;",
			"    if (head) head->prev = NULL;",
			"    free(temp);",
			"    return head;",
			"}"
		],
		"description": "Delete first node of DLL"
	},
	"DLL traverse forward": {
		"prefix": "dlltravf",
		"body": [
			"void traverseForward(struct DNode* head) {",
			"    while (head) { printf(\"%d \", head->data); head = head->next; }",
			"    printf(\"\\n\");",
			"}"
		],
		"description": "Traverse DLL forward"
	},
	"DLL traverse backward": {
		"prefix": "dlltravb",
		"body": [
			"void traverseBackward(struct DNode* head) {",
			"    if (!head) return;",
			"    while (head->next) head = head->next;",
			"    while (head) { printf(\"%d \", head->data); head = head->prev; }",
			"    printf(\"\\n\");",
			"}"
		],
		"description": "Traverse DLL backward"
	},
	"StackLL struct": {
		"prefix": "stackllstruct",
		"body": [
			"struct Node { int data; struct Node* next; };"
		],
		"description": "Stack node struct for linked list"
	},
	"StackLL push": {
		"prefix": "stackllpush",
		"body": [
			"struct Node* push(struct Node* top, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val; newNode->next = top;",
			"    return newNode;",
			"}"
		],
		"description": "Push onto stack using linked list"
	},
	"StackLL pop": {
		"prefix": "stackllpop",
		"body": [
			"struct Node* pop(struct Node* top) {",
			"    if (!top) { printf(\"Stack Underflow\\n\"); return NULL; }",
			"    struct Node* temp = top;",
			"    printf(\"Popped %d\\n\", temp->data);",
			"    top = top->next;",
			"    free(temp);",
			"    return top;",
			"}"
		],
		"description": "Pop from stack using linked list"
	},
	"StackLL display": {
		"prefix": "stacklldisp",
		"body": [
			"void display(struct Node* top) {",
			"    while (top) { printf(\"%d -> \", top->data); top = top->next; }",
			"    printf(\"NULL\\n\");",
			"}"
		],
		"description": "Display stack using linked list"
	},
	"QueueLL struct": {
		"prefix": "queuellstruct",
		"body": [
			"struct Node { int data; struct Node* next; };"
		],
		"description": "Queue node struct for linked list"
	},
	"QueueLL enqueue": {
		"prefix": "queuellenq",
		"body": [
			"struct Node* enqueue(struct Node* rear, int val) {",
			"    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));",
			"    newNode->data = val; newNode->next = NULL;",
			"    if (rear) rear->next = newNode;",
			"    return newNode;",
			"}"
		],
		"description": "Enqueue into queue using linked list"
	},
	"QueueLL dequeue": {
		"prefix": "queuelldeq",
		"body": [
			"struct Node* dequeue(struct Node* front) {",
			"    if (!front) { printf(\"Queue Empty\\n\"); return NULL; }",
			"    struct Node* temp = front;",
			"    printf(\"Dequeued %d\\n\", temp->data);",
			"    front = front->next;",
			"    free(temp);",
			"    return front;",
			"}"
		],
		"description": "Dequeue from queue using linked list"
	},
	"QueueLL display": {
		"prefix": "queuelldisp",
		"body": [
			"void display(struct Node* front) {",
			"    while (front) { printf(\"%d -> \", front->data); front = front->next; }",
			"    printf(\"NULL\\n\");",
			"}"
		],
		"description": "Display queue using linked list"
	},
	"BT struct": {
		"prefix": "btstruct",
		"body": [
			"struct Node { int data; struct Node *left, *right; };",
			"struct Node* newNode(int val) {",
			"    struct Node* node = (struct Node*)malloc(sizeof(struct Node));",
			"    node->data = val; node->left = node->right = NULL; return node; }"
		],
		"description": "Binary tree node struct and constructor"
	},
	"BT inorder": {
		"prefix": "btinorder",
		"body": [
			"void inorder(struct Node* root) {",
			"    if (root) {",
			"        inorder(root->left);",
			"        printf(\"%d \", root->data);",
			"        inorder(root->right);",
			"    }",
			"}"
		],
		"description": "Inorder traversal of binary tree"
	},
	"BT preorder": {
		"prefix": "btpreorder",
		"body": [
			"void preorder(struct Node* root) {",
			"    if (root) {",
			"        printf(\"%d \", root->data);",
			"        preorder(root->left);",
			"        preorder(root->right);",
			"    }",
			"}"
		],
		"description": "Preorder traversal of binary tree"
	},
	"BT postorder": {
		"prefix": "btpostorder",
		"body": [
			"void postorder(struct Node* root) {",
			"    if (root) {",
			"        postorder(root->left);",
			"        postorder(root->right);",
			"        printf(\"%d \", root->data);",
			"    }",
			"}"
		],
		"description": "Postorder traversal of binary tree"
	},
	"BST insert": {
		"prefix": "bstins",
		"body": [
			"struct Node* insert(struct Node* root, int val) {",
			"    if (!root) return newNode(val);",
			"    if (val < root->data) root->left = insert(root->left, val);",
			"    else if (val > root->data) root->right = insert(root->right, val);",
			"    return root;",
			"}"
		],
		"description": "Insert node into BST"
	},
	"BST search": {
		"prefix": "bstsearch",
		"body": [
			"struct Node* search(struct Node* root, int key) {",
			"    if (!root || root->data == key) return root;",
			"    if (key < root->data) return search(root->left, key);",
			"    return search(root->right, key);",
			"}"
		],
		"description": "Search for a key in BST"
	},
	"BST find min": {
		"prefix": "bstmin",
		"body": [
			"struct Node* findMin(struct Node* root) {",
			"    while (root && root->left) root = root->left;",
			"    return root;",
			"}"
		],
		"description": "Find minimum value node in BST"
	},
	"BST find max": {
		"prefix": "bstmax",
		"body": [
			"struct Node* findMax(struct Node* root) {",
			"    while (root && root->right) root = root->right;",
			"    return root;",
			"}"
		],
		"description": "Find maximum value node in BST"
	},
	"BST delete": {
		"prefix": "bstdel",
		"body": [
			"struct Node* deleteNode(struct Node* root, int key) {",
			"    if (!root) return root;",
			"    if (key < root->data) root->left = deleteNode(root->left, key);",
			"    else if (key > root->data) root->right = deleteNode(root->right, key);",
			"    else {",
			"        if (!root->left) { struct Node* temp = root->right; free(root); return temp; }",
			"        else if (!root->right) { struct Node* temp = root->left; free(root); return temp; }",
			"        struct Node* temp = findMin(root->right);",
			"        root->data = temp->data;",
			"        root->right = deleteNode(root->right, temp->data);",
			"    }",
			"    return root;",
			"}"
		],
		"description": "Delete node from BST"
	},
	"AVL right rotate": {
		"prefix": "avlrr",
		"body": [
			"struct Node* rightRotate(struct Node* y) {",
			"    struct Node* x = y->left;",
			"    struct Node* T2 = x->right;",
			"    x->right = y;",
			"    y->left = T2;",
			"    return x;",
			"}"
		],
		"description": "Right rotation for AVL tree"
	},
	"AVL left rotate": {
		"prefix": "avllr",
		"body": [
			"struct Node* leftRotate(struct Node* x) {",
			"    struct Node* y = x->right;",
			"    struct Node* T2 = y->left;",
			"    y->left = x;",
			"    x->right = T2;",
			"    return y;",
			"}"
		],
		"description": "Left rotation for AVL tree"
	},
	"AVL get height": {
		"prefix": "avlheight",
		"body": [
			"int height(struct Node* n) {",
			"    if (!n) return 0;",
			"    int lh = height(n->left);",
			"    int rh = height(n->right);",
			"    return (lh > rh ? lh : rh) + 1;",
			"}"
		],
		"description": "Get height of AVL tree node"
	},
	"AVL get balance": {
		"prefix": "avlbal",
		"body": [
			"int getBalance(struct Node* n) {",
			"    if (!n) return 0;",
			"    return height(n->left) - height(n->right);",
			"}"
		],
		"description": "Get balance factor of AVL node"
	},
	"BTree node struct": {
		"prefix": "btreestruct",
		"body": [
			"struct BTreeNode {",
			"    int *keys; int t; int n; int leaf;",
			"    struct BTreeNode **C;",
			"};"
		],
		"description": "Basic B-Tree node struct"
	},
	"Stack struct": {
		"prefix": "stackstruct",
		"body": [
			"#define MAX 100",
			"int stack[MAX];",
			"int top = -1;"
		],
		"description": "Stack using array struct (global variables)"
	},
	"Stack push": {
		"prefix": "stackpush",
		"body": [
			"void push(int val) {",
			"    if (top == MAX - 1) { printf(\"Stack Overflow\\n\"); return; }",
			"    stack[++top] = val;",
			"}"
		],
		"description": "Push element onto stack"
	},
	"Stack pop": {
		"prefix": "stackpop",
		"body": [
			"int pop() {",
			"    if (top == -1) { printf(\"Stack Underflow\\n\"); return -1; }",
			"    return stack[top--];",
			"}"
		],
		"description": "Pop element from stack"
	},
	"Stack peek": {
		"prefix": "stackpeek",
		"body": [
			"int peek() {",
			"    if (top == -1) { printf(\"Stack Empty\\n\"); return -1; }",
			"    return stack[top];",
			"}"
		],
		"description": "Peek top element of stack"
	},
	"Stack isEmpty": {
		"prefix": "stackisempty",
		"body": [
			"int isEmpty() { return top == -1; }"
		],
		"description": "Check if stack is empty"
	},
	"Stack isFull": {
		"prefix": "stackisfull",
		"body": [
			"int isFull() { return top == MAX - 1; }"
		],
		"description": "Check if stack is full"
	},
	"Balanced parentheses": {
		"prefix": "balancedparens",
		"body": [
			"int isMatchingPair(char a, char b) {",
			"    return (a=='(' && b==')') || (a=='{' && b=='}') || (a=='[' && b==']');",
			"}",
			"",
			"int checkBalanced(char* expr) {",
			"    char stack[MAX]; int top=-1;",
			"    for (int i=0; expr[i]; i++) {",
			"        if (expr[i]=='('||expr[i]=='{'||expr[i]=='[') stack[++top]=expr[i];",
			"        else if (expr[i]==')'||expr[i]=='}'||expr[i]==']') {",
			"            if (top==-1 || !isMatchingPair(stack[top--], expr[i])) return 0;",
			"        }",
			"    }",
			"    return top==-1;",
			"}"
		],
		"description": "Check balanced parentheses using stack"
	},
	"Postfix evaluation": {
		"prefix": "postfixeval",
		"body": [
			"int evaluatePostfix(char* expr) {",
			"    int stack[MAX]; int top=-1;",
			"    for (int i=0; expr[i]; i++) {",
			"        if (isdigit(expr[i])) stack[++top] = expr[i]-'0';",
			"        else {",
			"            int b = stack[top--]; int a = stack[top--];",
			"            switch(expr[i]) {",
			"                case '+': stack[++top] = a+b; break;",
			"                case '-': stack[++top] = a-b; break;",
			"                case '*': stack[++top] = a*b; break;",
			"                case '/': stack[++top] = a/b; break;",
			"            }",
			"        }",
			"    }",
			"    return stack[top];",
			"}"
		],
		"description": "Evaluate postfix expression using stack"
	},
	"Infix to postfix": {
		"prefix": "infixtopostfix",
		"body": [
			"int precedence(char op) {",
			"    if (op=='+'||op=='-') return 1;",
			"    if (op=='*'||op=='/') return 2;",
			"    return 0;",
			"}",
			"",
			"void infixToPostfix(char* expr) {",
			"    char stack[MAX]; int top=-1;",
			"    for (int i=0; expr[i]; i++) {",
			"        if (isalnum(expr[i])) printf(\"%c\", expr[i]);",
			"        else if (expr[i]=='(') stack[++top] = '(';",
			"        else if (expr[i]==')') {",
			"            while (top!=-1 && stack[top]!='(') printf(\"%c\", stack[top--]);",
			"            top--;",
			"        } else {",
			"            while (top!=-1 && precedence(stack[top])>=precedence(expr[i]))",
			"                printf(\"%c\", stack[top--]);",
			"            stack[++top] = expr[i];",
			"        }",
			"    }",
			"    while (top!=-1) printf(\"%c\", stack[top--]);",
			"}"
		],
		"description": "Convert infix expression to postfix using stack"
	},
	"Queue struct": {
		"prefix": "queuestruct",
		"body": [
			"#define MAX 100",
			"int queue[MAX]; int front=-1, rear=-1;"
		],
		"description": "Queue using array struct (global variables)"
	},
	"Queue enqueue": {
		"prefix": "queueenq",
		"body": [
			"void enqueue(int val) {",
			"    if (rear==MAX-1) { printf(\"Queue Overflow\\n\"); return; }",
			"    if (front==-1) front=0;",
			"    queue[++rear] = val;",
			"}"
		],
		"description": "Enqueue into simple queue"
	},
	"Queue dequeue": {
		"prefix": "queuedeq",
		"body": [
			"int dequeue() {",
			"    if (front==-1 || front>rear) { printf(\"Queue Underflow\\n\"); return -1; }",
			"    return queue[front++];",
			"}"
		],
		"description": "Dequeue from simple queue"
	},
	"Queue display": {
		"prefix": "queuedisp",
		"body": [
			"void display() {",
			"    if (front==-1 || front>rear) { printf(\"Queue Empty\\n\"); return; }",
			"    for (int i=front; i<=rear; i++) printf(\"%d \", queue[i]);",
			"    printf(\"\\n\");",
			"}"
		],
		"description": "Display simple queue"
	},
	"Circular queue enqueue": {
		"prefix": "cqueueenq",
		"body": [
			"void enqueueCQ(int val) {",
			"    if ((rear+1)%MAX == front) { printf(\"Queue Full\\n\"); return; }",
			"    if (front==-1) front=0;",
			"    rear=(rear+1)%MAX;",
			"    queue[rear]=val;",
			"}"
		],
		"description": "Enqueue into circular queue"
	},
	"Circular queue dequeue": {
		"prefix": "cqueuedeq",
		"body": [
			"int dequeueCQ() {",
			"    if (front==-1) { printf(\"Queue Empty\\n\"); return -1; }",
			"    int val=queue[front];",
			"    if (front==rear) front=rear=-1;",
			"    else front=(front+1)%MAX;",
			"    return val;",
			"}"
		],
		"description": "Dequeue from circular queue"
	},
	"Circular queue display": {
		"prefix": "cqueuedisp",
		"body": [
			"void displayCQ() {",
			"    if (front==-1) { printf(\"Queue Empty\\n\"); return; }",
			"    int i=front;",
			"    while (1) {",
			"        printf(\"%d \", queue[i]);",
			"        if (i==rear) break;",
			"        i=(i+1)%MAX;",
			"    }",
			"    printf(\"\\n\");",
			"}"
		],
		"description": "Display circular queue"
	},
	"Queue using two stacks enqueue": {
		"prefix": "queue2enq",
		"body": [
			"void enqueue2(int val) {",
			"    s1[++top1] = val;",
			"}"
		],
		"description": "Enqueue using two stacks"
	},
	"Queue using two stacks dequeue": {
		"prefix": "queue2deq",
		"body": [
			"int dequeue2() {",
			"    if (top1 == -1 && top2 == -1) {",
			"        printf(\"Queue Empty\\n\");",
			"        return -1;",
			"    }",
			"    if (top2 == -1) {",
			"        while (top1 != -1) {",
			"            s2[++top2] = s1[top1--];",
			"        }",
			"    }",
			"    return s2[top2--];",
			"}"
		],
		"description": "Dequeue using two stacks"
	},
	"Queue using two stacks display": {
		"prefix": "queue2disp",
		"body": [
			"void display2() {",
			"    if (top1 == -1 && top2 == -1) {",
			"        printf(\"Queue Empty\\n\");",
			"        return;",
			"    }",
			"    if (top2 != -1) {",
			"        for (int i = top2; i >= 0; i--) printf(\"%d \", s2[i]);",
			"    }",
			"    for (int i = 0; i <= top1; i++) printf(\"%d \", s1[i]);",
			"    printf(\"\\n\");",
			"}"
		],
		"description": "Display queue implemented using two stacks"
	},
	"AVL insert": {
		"prefix": "avlins",
		"body": [
			"struct Node* insertAVL(struct Node* node, int key) {",
			"    if (!node) return newNode(key);",
			"    if (key < node->data) node->left = insertAVL(node->left, key);",
			"    else if (key > node->data) node->right = insertAVL(node->right, key);",
			"    else return node;",
			"",
			"    int balance = getBalance(node);",
			"",
			"    if (balance > 1 && key < node->left->data) return rightRotate(node);",
			"    if (balance < -1 && key > node->right->data) return leftRotate(node);",
			"    if (balance > 1 && key > node->left->data) {",
			"        node->left = leftRotate(node->left);",
			"        return rightRotate(node);",
			"    }",
			"    if (balance < -1 && key < node->right->data) {",
			"        node->right = rightRotate(node->right);",
			"        return leftRotate(node);",
			"    }",
			"    return node;",
			"}"
		],
		"description": "Insert into AVL tree with balancing"
	},
	"BTree create node": {
		"prefix": "btcreate",
		"body": [
			"struct BTreeNode* createNode(int t, int leaf) {",
			"    struct BTreeNode* node = (struct BTreeNode*)malloc(sizeof(struct BTreeNode));",
			"    node->t = t; node->leaf = leaf; node->n = 0;",
			"    node->keys = (int*)malloc((2*t-1)*sizeof(int));",
			"    node->C = (struct BTreeNode**)malloc((2*t)*sizeof(struct BTreeNode*));",
			"    return node;",
			"}"
		],
		"description": "Create a new B-Tree node"
	},
	"BTree search": {
		"prefix": "btsearch",
		"body": [
			"struct BTreeNode* searchBTree(struct BTreeNode* root, int k) {",
			"    int i = 0;",
			"    while (i < root->n && k > root->keys[i]) i++;",
			"    if (i < root->n && root->keys[i] == k) return root;",
			"    if (root->leaf) return NULL;",
			"    return searchBTree(root->C[i], k);",
			"}"
		],
		"description": "Search for key in B-Tree"
	},
	"BTree split child": {
		"prefix": "btsplit",
		"body": [
			"void splitChild(struct BTreeNode* x, int i, struct BTreeNode* y) {",
			"    int t = y->t;",
			"    struct BTreeNode* z = createNode(t, y->leaf);",
			"    z->n = t - 1;",
			"    for (int j = 0; j < t-1; j++) z->keys[j] = y->keys[j+t];",
			"    if (!y->leaf) {",
			"        for (int j = 0; j < t; j++) z->C[j] = y->C[j+t];",
			"    }",
			"    y->n = t - 1;",
			"    for (int j = x->n; j >= i+1; j--) x->C[j+1] = x->C[j];",
			"    x->C[i+1] = z;",
			"    for (int j = x->n-1; j >= i; j--) x->keys[j+1] = x->keys[j];",
			"    x->keys[i] = y->keys[t-1];",
			"    x->n = x->n + 1;",
			"}"
		],
		"description": "Split child in B-Tree during insertion"
	},
	"BTree insert nonfull": {
		"prefix": "btinsnonfull",
		"body": [
			"void insertNonFull(struct BTreeNode* x, int k) {",
			"    int i = x->n - 1;",
			"    if (x->leaf) {",
			"        while (i >= 0 && k < x->keys[i]) { x->keys[i+1] = x->keys[i]; i--; }",
			"        x->keys[i+1] = k; x->n = x->n + 1;",
			"    } else {",
			"        while (i >= 0 && k < x->keys[i]) i--; i++;",
			"        if (x->C[i]->n == 2*x->t - 1) {",
			"            splitChild(x, i, x->C[i]);",
			"            if (k > x->keys[i]) i++;",
			"        }",
			"        insertNonFull(x->C[i], k);",
			"    }",
			"}"
		],
		"description": "Insert into non-full B-Tree node"
	},
	"BTree insert": {
		"prefix": "btinsert",
		"body": [
			"struct BTreeNode* insertBTree(struct BTreeNode* root, int k) {",
			"    if (root->n == 2*root->t - 1) {",
			"        struct BTreeNode* s = createNode(root->t, 0);",
			"        s->C[0] = root;",
			"        splitChild(s, 0, root);",
			"        int i = 0;",
			"        if (s->keys[0] < k) i++;",
			"        insertNonFull(s->C[i], k);",
			"        return s;",
			"    } else {",
			"        insertNonFull(root, k);",
			"        return root;",
			"    }",
			"}"
		],
		"description": "Insert key into B-Tree"
	}
}